{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"EloGrad","text":"<p>Extended Elo rating system implementation based on the equivalence with logistic regression.</p> <p>EloGrad (Elo as Gradient descent) leverages the framing of the  Elo rating system as logistic regression with stochastic gradient descent (see Elo as Logistic Regression for a walkthrough) to offer a collection of extensions to the rating system. All rating systems are <code>narwhals</code> compatible for dataframe libraries with  full API support.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Standard Elo rating system for binary outcomes.<ul> <li><code>narwhals</code> compatible.</li> <li>A <code>scikit-learn</code> compatible implementation is available in the <code>sklearn</code> submodule.</li> <li>See <code>examples/nba.ipynb</code> for an example using NBA data and <code>polars</code>.</li> </ul> </li> <li>Elo rating system for binary outcomes with additional regressors, e.g. home advantage.<ul> <li>L1 and L2 regularisation supported for additional regressors (see Regularisation).</li> <li>See Additional Regressors for the theory and <code>examples/nba.ipynb</code> for an example using NBA data and <code>polars</code>.</li> </ul> </li> <li>Elo rating system for count data based on Poisson regression.<ul> <li><code>narwhals</code> compatible.</li> <li>A <code>scikit-learn</code> compatible implementation is available in the <code>sklearn</code> submodule.</li> <li>See Poisson Elo for the theory and <code>examples/football.ipynb</code> for an example using Premier League football data and <code>pandas</code>.</li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>You can install <code>elo-grad</code> with: <pre><code>pip install elo-grad\n</code></pre> For the <code>scikit-learn</code> compatible rating systems, the <code>sklearn</code> optional dependencies must be installed as: <pre><code>pip install elo-grad[sklearn]\n</code></pre></p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Detailed example notebooks are provided in the <code>examples/</code> directory. To install any extra dependencies required to run the notebooks install with: <pre><code>pip install elo-grad[examples]\n</code></pre></p>"},{"location":"#minimal-example","title":"Minimal Example","text":"<pre><code>from elo_grad import EloEstimator, Regressor\n\n# Input dataframe with columns \n# t | entity_1 | entity_2 | score | home\n# sorted (in ascending order) on t\n# where t is the Unix timestamp (in seconds) of\n# the game and score = 1 if player_1 won and score = 0 \n# if player_2 won and home is a boolean flag indicating \n# if entity_1 has home advantage.\ndf = ...\nestimator = EloEstimator(\n    k_factor=20, \n    default_init_rating=1200,\n    entity_cols=(\"player_1\", \"player_2\"),\n    score_col=\"result\",\n    date_col=\"t\",\n    init_ratings=dict(home=(None, 0)),\n    additional_regressors=[Regressor(name='home', k_factor=0.1)],\n)\n# Get expected scores\nexpected_scores = estimator.predict_proba(df)\n# Get final ratings (of form (Unix timestamp, rating))\nratings = estimator.model.ratings\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":"<p>In rough order, things we want to add are:</p> <ul> <li>Head-to-head ratings</li> <li>Bivariate Poisson</li> <li>Interaction terms</li> <li>Other optimizers, e.g. momentum</li> <li>Extend plotting support, e.g. plotly</li> <li>Support hierarchical matches, e.g. tennis matches with sets and games</li> </ul>"},{"location":"#references","title":"References","text":"<ol> <li>Elo rating system: https://en.wikipedia.org/wiki/Elo_rating_system</li> <li>Elo rating system as logistic regression with stochastic gradient descent: https://stmorse.github.io/journal/Elo.html</li> <li>Elo rating system for NFL predictions: https://fivethirtyeight.com/methodology/how-our-nfl-predictions-work/</li> <li>Elo rating system based on Poisson regression: https://github.com/octonion/puzzles/blob/master/elo/poisson.py</li> </ol>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#elo_grad.BaseEloEstimator","title":"<code>BaseEloEstimator</code>","text":"<p>               Bases: <code>HistoryPlotterMixin</code></p> <p>Elo rating system classifier.</p> <p>Attributes:</p> Name Type Description <code>model_type</code> <code>Type[Model]</code> <p>Base model class type.</p> <code>beta</code> <code>float</code> <p>Normalization factor for ratings when computing expected score.</p> <code>columns</code> <code>List[str]</code> <p>[entity_1, entity_2, result] columns names.</p> <code>default_init_rating</code> <code>float</code> <p>Default initial rating for entities.</p> <code>entity_cols</code> <code>Tuple[str, str]</code> <p>Names of columns identifying the names of the entities playing the games.</p> <code>init_ratings</code> <code>Optional[Dict[str, Tuple[Optional[int], float]]]</code> <p>Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))</p> <code>k_factor</code> <code>float</code> <p>Elo K-factor/step-size for gradient descent.</p> <code>model</code> <code>Model</code> <p>Underlying statistical model.</p> <code>optimizer</code> <code>Optimizer</code> <p>Optimizer to update the model.</p> <code>rating_history</code> <code>List[Tuple[Optional[int], float]]</code> <p>Historical ratings of entities (if track_rating_history is True).</p> <code>score_col</code> <code>str</code> <p>Name of score column (1 if entity_1 wins and 0 if entity_2 wins). Draws are not currently supported.</p> <code>date_col</code> <code>str</code> <p>Name of date column, which has Unix timestamp (in seconds) of the game.</p> <code>additional_regressors</code> <code>Optional[List[Regressor]]</code> <p>Additional regressors to include, e.g. home advantage.</p> <code>track_rating_history</code> <code>bool</code> <p>Flag to track historical ratings of entities.</p> <p>Methods:</p> Name Description <code>fit</code> <p>Fit Elo rating system/calculate ratings.</p> <code>record_ratings</code> <p>Record the current ratings of entities.</p> <code>predict_proba</code> <p>Produce probability estimates.</p> <code>predict</code> <p>Predict outcome of game.</p> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>class BaseEloEstimator(HistoryPlotterMixin):\n    \"\"\"\n    Elo rating system classifier.\n\n    Attributes\n    ----------\n    model_type : Type[Model]\n        Base model class type.\n    beta : float\n        Normalization factor for ratings when computing expected score.\n    columns : List[str]\n        [entity_1, entity_2, result] columns names.\n    default_init_rating : float\n        Default initial rating for entities.\n    entity_cols : Tuple[str, str]\n        Names of columns identifying the names of the entities playing the games.\n    init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n        Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n    k_factor : float\n        Elo K-factor/step-size for gradient descent.\n    model : Model\n        Underlying statistical model.\n    optimizer : Optimizer\n        Optimizer to update the model.\n    rating_history : List[Tuple[Optional[int], float]]\n        Historical ratings of entities (if track_rating_history is True).\n    score_col : str\n        Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n        Draws are not currently supported.\n    date_col : str\n        Name of date column, which has Unix timestamp (in seconds) of the\n        game.\n    additional_regressors : Optional[List[Regressor]]\n        Additional regressors to include, e.g. home advantage.\n    track_rating_history : bool\n        Flag to track historical ratings of entities.\n\n    Methods\n    -------\n    fit(X, y=None)\n        Fit Elo rating system/calculate ratings.\n    record_ratings()\n        Record the current ratings of entities.\n    predict_proba(X)\n        Produce probability estimates.\n    predict(X)\n        Predict outcome of game.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_type: Type[Model],\n        k_factor: float,\n        default_init_rating: float,\n        beta: float,\n        init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]],\n        entity_cols: Tuple[str, str],\n        score_col: str,\n        date_col: str,\n        additional_regressors: Optional[List[Regressor]],\n        track_rating_history: bool,\n    ) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        model_type : Type[Model]\n            Base model class type.\n        k_factor : float\n            Elo K-factor/step-size for gradient descent for the entities.\n        default_init_rating : float\n            Default initial rating for entities.\n        beta : float\n            Normalization factor for ratings when computing expected score.\n        init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n            Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n        entity_cols : Tuple[str, str]\n            Names of columns identifying the names of the entities playing the games.\n        score_col : str\n            Name of score column\n        date_col : str\n            Name of date column, which has Unix timestamp (in seconds) of the\n            game.\n        additional_regressors : Optional[List[Regressor]]\n            Additional regressors to include, e.g. home advantage.\n        track_rating_history : bool\n            Flag to track historical ratings of entities.\n        \"\"\"\n        self.entity_cols: Tuple[str, str] = entity_cols\n        self.score_col: str = score_col\n        self.date_col: str = date_col\n        self.columns: List[str] = [date_col, *entity_cols, score_col]\n        self.beta: float = beta\n        self.default_init_rating: float = default_init_rating\n        self.init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]] = init_ratings\n        self.model_type: Type[Model] = model_type\n        self.model: Model = model_type(\n            beta=beta,\n            default_init_rating=default_init_rating,\n            init_ratings=init_ratings,\n        )\n        self.additional_regressors: List[Regressor] = additional_regressors if additional_regressors is not None else []\n        if additional_regressors is not None:\n            self.columns.extend([r.name for r in additional_regressors])\n        self.k_factor: float = k_factor\n        self.optimizer: Optimizer = SGDOptimizer(\n            k_factor=self.k_factor,\n            additional_regressors=self.additional_regressors,\n        )\n        self.track_rating_history: bool = track_rating_history\n        self.rating_history: List[Tuple[Optional[int], float]] = defaultdict(list)  # type:ignore\n\n    def reinitialize(self) -&gt; None:\n        \"\"\"\n        Reinitialize the rating system after parameter changes.\n        Helpful when performing a grid search.\n        \"\"\"\n        self.model = self.model_type(\n            beta=self.beta,\n            default_init_rating=self.default_init_rating,\n            init_ratings=self.init_ratings,\n        )\n        self.optimizer = SGDOptimizer(k_factor=self.k_factor, additional_regressors=self.additional_regressors)\n\n    def _update_ratings(self, t: int, rating_deltas: Dict[str, float]) -&gt; None:\n        for entity in rating_deltas:\n            self.model.ratings[entity] = (t, self.model.ratings[entity][1] + rating_deltas[entity])\n\n    def record_ratings(self) -&gt; None:\n        \"\"\"\n        Record the current ratings of entities.\n        \"\"\"\n        for k, v in self.model.ratings.items():\n            self.rating_history[k].append(v)  # type:ignore\n\n    def _transform(self, X, return_expected_score):\n        df: nw.DataFrame = nw.from_native(X)\n        native_namespace: Any = nw.get_native_namespace(df)\n        df = df.select(self.columns)\n\n        if not df[self.date_col].is_sorted(descending=False):\n            raise ValueError(\"DataFrame must be sorted by date.\")\n        current_ix: int = df[self.date_col].item(0)\n\n        additional_regressor_flag: bool = len(self.additional_regressors) &gt; 0\n        additional_regressor_contrib: float = 0.0\n        additional_regressor_values: Optional[Tuple[float, ...]] = None\n        preds = array(\"f\") if return_expected_score else None\n        rating_deltas: Dict[str, float] = defaultdict(float)\n        for row in df.iter_rows(named=False, buffer_size=512):\n            if additional_regressor_flag:\n                ix, entity_1, entity_2, score, *additional_regressor_values = row\n            else:\n                ix, entity_1, entity_2, score = row\n\n            if ix != current_ix:\n                self._update_ratings(ix, rating_deltas)\n                current_ix, rating_deltas = ix, defaultdict(float)\n                if self.track_rating_history:\n                    self.record_ratings()\n\n            if additional_regressor_flag:\n                additional_regressor_contrib = sum(\n                    self.model.ratings[k.name][1] * v  # type:ignore\n                    for k, v in zip(self.additional_regressors, additional_regressor_values)  # type:ignore\n                )\n\n            expected_score: float = self.model.calculate_expected_score(\n                self.model.ratings[entity_1][1],\n                -self.model.ratings[entity_2][1],\n                additional_regressor_contrib,\n            )\n            if return_expected_score:\n                preds.append(expected_score)  # type:ignore\n\n            _rating_deltas: Generator[float, None, None] = self.optimizer.calculate_update_step(\n                model=self.model,\n                y=score,\n                entity_1=entity_1,\n                entity_2=entity_2,\n                additional_regressor_values=additional_regressor_values,\n                expected_score=expected_score,\n            )\n            entity_update: float = next(_rating_deltas)\n            rating_deltas[entity_1] += entity_update\n            rating_deltas[entity_2] -= entity_update\n            if additional_regressor_flag:\n                for r in self.additional_regressors:\n                    rating_deltas[r.name] += next(_rating_deltas)\n\n        self._update_ratings(ix, rating_deltas)\n        if self.track_rating_history:\n            self.record_ratings()\n\n        if return_expected_score:\n            return nw.new_series(name=PRED_PROBA, values=preds, native_namespace=native_namespace)\n        return None\n\n    def fit(self, X, y=None):\n        self._transform(X, return_expected_score=False)\n        return self\n</code></pre>"},{"location":"api/#elo_grad.BaseEloEstimator.__init__","title":"<code>__init__(model_type, k_factor, default_init_rating, beta, init_ratings, entity_cols, score_col, date_col, additional_regressors, track_rating_history)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[Model]</code> <p>Base model class type.</p> required <code>k_factor</code> <code>float</code> <p>Elo K-factor/step-size for gradient descent for the entities.</p> required <code>default_init_rating</code> <code>float</code> <p>Default initial rating for entities.</p> required <code>beta</code> <code>float</code> <p>Normalization factor for ratings when computing expected score.</p> required <code>init_ratings</code> <code>Optional[Dict[str, Tuple[Optional[int], float]]]</code> <p>Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))</p> required <code>entity_cols</code> <code>Tuple[str, str]</code> <p>Names of columns identifying the names of the entities playing the games.</p> required <code>score_col</code> <code>str</code> <p>Name of score column</p> required <code>date_col</code> <code>str</code> <p>Name of date column, which has Unix timestamp (in seconds) of the game.</p> required <code>additional_regressors</code> <code>Optional[List[Regressor]]</code> <p>Additional regressors to include, e.g. home advantage.</p> required <code>track_rating_history</code> <code>bool</code> <p>Flag to track historical ratings of entities.</p> required Source code in <code>src/elo_grad/__init__.py</code> <pre><code>def __init__(\n    self,\n    model_type: Type[Model],\n    k_factor: float,\n    default_init_rating: float,\n    beta: float,\n    init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]],\n    entity_cols: Tuple[str, str],\n    score_col: str,\n    date_col: str,\n    additional_regressors: Optional[List[Regressor]],\n    track_rating_history: bool,\n) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    model_type : Type[Model]\n        Base model class type.\n    k_factor : float\n        Elo K-factor/step-size for gradient descent for the entities.\n    default_init_rating : float\n        Default initial rating for entities.\n    beta : float\n        Normalization factor for ratings when computing expected score.\n    init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n        Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n    entity_cols : Tuple[str, str]\n        Names of columns identifying the names of the entities playing the games.\n    score_col : str\n        Name of score column\n    date_col : str\n        Name of date column, which has Unix timestamp (in seconds) of the\n        game.\n    additional_regressors : Optional[List[Regressor]]\n        Additional regressors to include, e.g. home advantage.\n    track_rating_history : bool\n        Flag to track historical ratings of entities.\n    \"\"\"\n    self.entity_cols: Tuple[str, str] = entity_cols\n    self.score_col: str = score_col\n    self.date_col: str = date_col\n    self.columns: List[str] = [date_col, *entity_cols, score_col]\n    self.beta: float = beta\n    self.default_init_rating: float = default_init_rating\n    self.init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]] = init_ratings\n    self.model_type: Type[Model] = model_type\n    self.model: Model = model_type(\n        beta=beta,\n        default_init_rating=default_init_rating,\n        init_ratings=init_ratings,\n    )\n    self.additional_regressors: List[Regressor] = additional_regressors if additional_regressors is not None else []\n    if additional_regressors is not None:\n        self.columns.extend([r.name for r in additional_regressors])\n    self.k_factor: float = k_factor\n    self.optimizer: Optimizer = SGDOptimizer(\n        k_factor=self.k_factor,\n        additional_regressors=self.additional_regressors,\n    )\n    self.track_rating_history: bool = track_rating_history\n    self.rating_history: List[Tuple[Optional[int], float]] = defaultdict(list)  # type:ignore\n</code></pre>"},{"location":"api/#elo_grad.BaseEloEstimator.record_ratings","title":"<code>record_ratings()</code>","text":"<p>Record the current ratings of entities.</p> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>def record_ratings(self) -&gt; None:\n    \"\"\"\n    Record the current ratings of entities.\n    \"\"\"\n    for k, v in self.model.ratings.items():\n        self.rating_history[k].append(v)  # type:ignore\n</code></pre>"},{"location":"api/#elo_grad.BaseEloEstimator.reinitialize","title":"<code>reinitialize()</code>","text":"<p>Reinitialize the rating system after parameter changes. Helpful when performing a grid search.</p> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>def reinitialize(self) -&gt; None:\n    \"\"\"\n    Reinitialize the rating system after parameter changes.\n    Helpful when performing a grid search.\n    \"\"\"\n    self.model = self.model_type(\n        beta=self.beta,\n        default_init_rating=self.default_init_rating,\n        init_ratings=self.init_ratings,\n    )\n    self.optimizer = SGDOptimizer(k_factor=self.k_factor, additional_regressors=self.additional_regressors)\n</code></pre>"},{"location":"api/#elo_grad.ClassifierRatingSystemMixin","title":"<code>ClassifierRatingSystemMixin</code>","text":"<p>               Bases: <code>RatingSystemMixin</code></p> <p>Mixin class for classification rating systems.</p> <p>This mixin defines the following functionality:</p> <ul> <li><code>_estimator_type</code> class attribute defaulting to <code>\"classifier\"</code>;</li> <li><code>score</code> method that default to :func:<code>~sklearn.metrics.log_loss</code>.</li> <li>enforce that <code>fit</code> does not require <code>y</code> to be passed through the <code>requires_y</code> tag.</li> </ul> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>class ClassifierRatingSystemMixin(RatingSystemMixin):\n    \"\"\"\n    Mixin class for classification rating systems.\n\n    This mixin defines the following functionality:\n\n    - `_estimator_type` class attribute defaulting to `\"classifier\"`;\n    - `score` method that default to :func:`~sklearn.metrics.log_loss`.\n    - enforce that `fit` does not require `y` to be passed through the `requires_y` tag.\n    \"\"\"\n\n    def predict_proba(self, X):\n        pred_proba = self._transform(X, return_expected_score=True)\n        return (\n            pred_proba\n            .to_frame()\n            .select(\n                (1 - nw.col(PRED_PROBA)).alias(\"0\"),\n                nw.col(PRED_PROBA).alias(\"1\"),\n            )\n        )\n\n    def predict(self, X):\n        return (self.predict_proba(X)[\"1\"] &gt;= 0.5).rename(PRED_PROBA)\n</code></pre>"},{"location":"api/#elo_grad.EloEstimator","title":"<code>EloEstimator</code>","text":"<p>               Bases: <code>ClassifierRatingSystemMixin</code>, <code>BaseEloEstimator</code></p> <p>Elo rating system classifier.</p> <p>Attributes:</p> Name Type Description <code>beta</code> <code>float</code> <p>Normalization factor for ratings when computing expected score.</p> <code>columns</code> <code>List[str]</code> <p>[entity_1, entity_2, result] columns names.</p> <code>default_init_rating</code> <code>float</code> <p>Default initial rating for entities.</p> <code>entity_cols</code> <code>Tuple[str, str]</code> <p>Names of columns identifying the names of the entities playing the games.</p> <code>init_ratings</code> <code>Optional[Dict[str, Tuple[Optional[int], float]]]</code> <p>Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))</p> <code>k_factor</code> <code>float</code> <p>Elo K-factor/step-size for gradient descent.</p> <code>model</code> <code>Model</code> <p>Underlying statistical model.</p> <code>optimizer</code> <code>Optimizer</code> <p>Optimizer to update the model.</p> <code>rating_history</code> <code>List[Tuple[Optional[int], float]]</code> <p>Historical ratings of entities (if track_rating_history is True).</p> <code>score_col</code> <code>str</code> <p>Name of score column (1 if entity_1 wins and 0 if entity_2 wins). Draws are not currently supported.</p> <code>date_col</code> <code>str</code> <p>Name of date column, which has Unix timestamp (in seconds) of the game.</p> <code>additional_regressors</code> <code>Optional[List[Regressor]]</code> <p>Additional regressors to include, e.g. home advantage.</p> <code>track_rating_history</code> <code>bool</code> <p>Flag to track historical ratings of entities.</p> <p>Methods:</p> Name Description <code>fit</code> <p>Fit Elo rating system/calculate ratings.</p> <code>record_ratings</code> <p>Record the current ratings of entities.</p> <code>predict_proba</code> <p>Produce probability estimates.</p> <code>predict</code> <p>Predict outcome of game.</p> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>class EloEstimator(ClassifierRatingSystemMixin, BaseEloEstimator):\n    \"\"\"\n    Elo rating system classifier.\n\n    Attributes\n    ----------\n    beta : float\n        Normalization factor for ratings when computing expected score.\n    columns : List[str]\n        [entity_1, entity_2, result] columns names.\n    default_init_rating : float\n        Default initial rating for entities.\n    entity_cols : Tuple[str, str]\n        Names of columns identifying the names of the entities playing the games.\n    init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n        Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n    k_factor : float\n        Elo K-factor/step-size for gradient descent.\n    model : Model\n        Underlying statistical model.\n    optimizer : Optimizer\n        Optimizer to update the model.\n    rating_history : List[Tuple[Optional[int], float]]\n        Historical ratings of entities (if track_rating_history is True).\n    score_col : str\n        Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n        Draws are not currently supported.\n    date_col : str\n        Name of date column, which has Unix timestamp (in seconds) of the\n        game.\n    additional_regressors : Optional[List[Regressor]]\n        Additional regressors to include, e.g. home advantage.\n    track_rating_history : bool\n        Flag to track historical ratings of entities.\n\n    Methods\n    -------\n    fit(X, y=None)\n        Fit Elo rating system/calculate ratings.\n    record_ratings()\n        Record the current ratings of entities.\n    predict_proba(X)\n        Produce probability estimates.\n    predict(X)\n        Predict outcome of game.\n    \"\"\"\n\n    def __init__(\n        self,\n        k_factor: float,\n        default_init_rating: float,\n        beta: float = 200,\n        init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]] = None,\n        entity_cols: Tuple[str, str] = (\"entity_1\", \"entity_2\"),\n        score_col: str = \"score\",\n        date_col: str = \"t\",\n        additional_regressors: Optional[List[Regressor]] = None,\n        track_rating_history: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        k_factor : float\n            Elo K-factor/step-size for gradient descent for the entities.\n        default_init_rating : float\n            Default initial rating for entities.\n        beta : float\n            Normalization factor for ratings when computing expected score.\n        init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n            Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n        entity_cols : Tuple[str, str]\n            Names of columns identifying the names of the entities playing the games.\n        score_col : str\n            Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n            Draws are not currently supported.\n        date_col : str\n            Name of date column, which has Unix timestamp (in seconds) of the\n            game.\n        additional_regressors : Optional[List[Regressor]]\n            Additional regressors to include, e.g. home advantage.\n        track_rating_history : bool\n            Flag to track historical ratings of entities.\n        \"\"\"\n        super().__init__(\n            model_type=LogisticRegression,\n            k_factor=k_factor,\n            default_init_rating=default_init_rating,\n            beta=beta,\n            init_ratings=init_ratings,\n            entity_cols=entity_cols,\n            score_col=score_col,\n            date_col=date_col,\n            additional_regressors=additional_regressors,\n            track_rating_history=track_rating_history,\n        )\n</code></pre>"},{"location":"api/#elo_grad.EloEstimator.__init__","title":"<code>__init__(k_factor, default_init_rating, beta=200, init_ratings=None, entity_cols=('entity_1', 'entity_2'), score_col='score', date_col='t', additional_regressors=None, track_rating_history=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>k_factor</code> <code>float</code> <p>Elo K-factor/step-size for gradient descent for the entities.</p> required <code>default_init_rating</code> <code>float</code> <p>Default initial rating for entities.</p> required <code>beta</code> <code>float</code> <p>Normalization factor for ratings when computing expected score.</p> <code>200</code> <code>init_ratings</code> <code>Optional[Dict[str, Tuple[Optional[int], float]]]</code> <p>Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))</p> <code>None</code> <code>entity_cols</code> <code>Tuple[str, str]</code> <p>Names of columns identifying the names of the entities playing the games.</p> <code>('entity_1', 'entity_2')</code> <code>score_col</code> <code>str</code> <p>Name of score column (1 if entity_1 wins and 0 if entity_2 wins). Draws are not currently supported.</p> <code>'score'</code> <code>date_col</code> <code>str</code> <p>Name of date column, which has Unix timestamp (in seconds) of the game.</p> <code>'t'</code> <code>additional_regressors</code> <code>Optional[List[Regressor]]</code> <p>Additional regressors to include, e.g. home advantage.</p> <code>None</code> <code>track_rating_history</code> <code>bool</code> <p>Flag to track historical ratings of entities.</p> <code>False</code> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>def __init__(\n    self,\n    k_factor: float,\n    default_init_rating: float,\n    beta: float = 200,\n    init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]] = None,\n    entity_cols: Tuple[str, str] = (\"entity_1\", \"entity_2\"),\n    score_col: str = \"score\",\n    date_col: str = \"t\",\n    additional_regressors: Optional[List[Regressor]] = None,\n    track_rating_history: bool = False,\n) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    k_factor : float\n        Elo K-factor/step-size for gradient descent for the entities.\n    default_init_rating : float\n        Default initial rating for entities.\n    beta : float\n        Normalization factor for ratings when computing expected score.\n    init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n        Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n    entity_cols : Tuple[str, str]\n        Names of columns identifying the names of the entities playing the games.\n    score_col : str\n        Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n        Draws are not currently supported.\n    date_col : str\n        Name of date column, which has Unix timestamp (in seconds) of the\n        game.\n    additional_regressors : Optional[List[Regressor]]\n        Additional regressors to include, e.g. home advantage.\n    track_rating_history : bool\n        Flag to track historical ratings of entities.\n    \"\"\"\n    super().__init__(\n        model_type=LogisticRegression,\n        k_factor=k_factor,\n        default_init_rating=default_init_rating,\n        beta=beta,\n        init_ratings=init_ratings,\n        entity_cols=entity_cols,\n        score_col=score_col,\n        date_col=date_col,\n        additional_regressors=additional_regressors,\n        track_rating_history=track_rating_history,\n    )\n</code></pre>"},{"location":"api/#elo_grad.PoissonEloEstimator","title":"<code>PoissonEloEstimator</code>","text":"<p>               Bases: <code>RegressionRatingSystemMixin</code>, <code>BaseEloEstimator</code></p> <p>Poisson Elo rating system.</p> <p>Attributes:</p> Name Type Description <code>beta</code> <code>float</code> <p>Normalization factor for ratings when computing expected score.</p> <code>columns</code> <code>List[str]</code> <p>[entity_1, entity_2, result] columns names.</p> <code>default_init_rating</code> <code>float</code> <p>Default initial rating for entities.</p> <code>entity_cols</code> <code>Tuple[str, str]</code> <p>Names of columns identifying the names of the entities playing the games.</p> <code>init_ratings</code> <code>Optional[Dict[str, Tuple[Optional[int], float]]]</code> <p>Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))</p> <code>k_factor</code> <code>float</code> <p>Elo K-factor/step-size for gradient descent.</p> <code>model</code> <code>Model</code> <p>Underlying statistical model.</p> <code>optimizer</code> <code>Optimizer</code> <p>Optimizer to update the model.</p> <code>rating_history</code> <code>List[Tuple[Optional[int], float]]</code> <p>Historical ratings of entities (if track_rating_history is True).</p> <code>score_col</code> <code>str</code> <p>Name of score column (1 if entity_1 wins and 0 if entity_2 wins). Draws are not currently supported.</p> <code>date_col</code> <code>str</code> <p>Name of date column, which has Unix timestamp (in seconds) of the game.</p> <code>additional_regressors</code> <code>Optional[List[Regressor]]</code> <p>Additional regressors to include, e.g. home advantage.</p> <code>track_rating_history</code> <code>bool</code> <p>Flag to track historical ratings of entities.</p> <p>Methods:</p> Name Description <code>fit</code> <p>Fit Elo rating system/calculate ratings.</p> <code>record_ratings</code> <p>Record the current ratings of entities.</p> <code>predict</code> <p>Predict score.</p> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>class PoissonEloEstimator(RegressionRatingSystemMixin, BaseEloEstimator):\n    \"\"\"\n    Poisson Elo rating system.\n\n    Attributes\n    ----------\n    beta : float\n        Normalization factor for ratings when computing expected score.\n    columns : List[str]\n        [entity_1, entity_2, result] columns names.\n    default_init_rating : float\n        Default initial rating for entities.\n    entity_cols : Tuple[str, str]\n        Names of columns identifying the names of the entities playing the games.\n    init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n        Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n    k_factor : float\n        Elo K-factor/step-size for gradient descent.\n    model : Model\n        Underlying statistical model.\n    optimizer : Optimizer\n        Optimizer to update the model.\n    rating_history : List[Tuple[Optional[int], float]]\n        Historical ratings of entities (if track_rating_history is True).\n    score_col : str\n        Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n        Draws are not currently supported.\n    date_col : str\n        Name of date column, which has Unix timestamp (in seconds) of the\n        game.\n    additional_regressors : Optional[List[Regressor]]\n        Additional regressors to include, e.g. home advantage.\n    track_rating_history : bool\n        Flag to track historical ratings of entities.\n\n    Methods\n    -------\n    fit(X, y=None)\n        Fit Elo rating system/calculate ratings.\n    record_ratings()\n        Record the current ratings of entities.\n    predict(X)\n        Predict score.\n    \"\"\"\n\n    def __init__(\n        self,\n        k_factor: float,\n        default_init_rating: float,\n        beta: float = 200,\n        init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]] = None,\n        entity_cols: Tuple[str, str] = (\"entity_1\", \"entity_2\"),\n        score_col: str = \"score\",\n        date_col: str = \"t\",\n        additional_regressors: Optional[List[Regressor]] = None,\n        track_rating_history: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Parameters\n        ----------\n        k_factor : float\n            Elo K-factor/step-size for gradient descent for the entities.\n        default_init_rating : float\n            Default initial rating for entities.\n        beta : float\n            Normalization factor for ratings when computing expected score.\n        init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n            Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n        entity_cols : Tuple[str, str]\n            Names of columns identifying the names of the entities playing the games.\n        score_col : str\n            Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n            Draws are not currently supported.\n        date_col : str\n            Name of date column, which has Unix timestamp (in seconds) of the\n            game.\n        additional_regressors : Optional[List[Regressor]]\n            Additional regressors to include, e.g. home advantage.\n        track_rating_history : bool\n            Flag to track historical ratings of entities.\n        \"\"\"\n        super().__init__(\n            model_type=PoissonRegression,\n            k_factor=k_factor,\n            default_init_rating=default_init_rating,\n            beta=beta,\n            init_ratings=init_ratings,\n            entity_cols=entity_cols,\n            score_col=score_col,\n            date_col=date_col,\n            additional_regressors=additional_regressors,\n            track_rating_history=track_rating_history,\n        )\n</code></pre>"},{"location":"api/#elo_grad.PoissonEloEstimator.__init__","title":"<code>__init__(k_factor, default_init_rating, beta=200, init_ratings=None, entity_cols=('entity_1', 'entity_2'), score_col='score', date_col='t', additional_regressors=None, track_rating_history=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>k_factor</code> <code>float</code> <p>Elo K-factor/step-size for gradient descent for the entities.</p> required <code>default_init_rating</code> <code>float</code> <p>Default initial rating for entities.</p> required <code>beta</code> <code>float</code> <p>Normalization factor for ratings when computing expected score.</p> <code>200</code> <code>init_ratings</code> <code>Optional[Dict[str, Tuple[Optional[int], float]]]</code> <p>Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))</p> <code>None</code> <code>entity_cols</code> <code>Tuple[str, str]</code> <p>Names of columns identifying the names of the entities playing the games.</p> <code>('entity_1', 'entity_2')</code> <code>score_col</code> <code>str</code> <p>Name of score column (1 if entity_1 wins and 0 if entity_2 wins). Draws are not currently supported.</p> <code>'score'</code> <code>date_col</code> <code>str</code> <p>Name of date column, which has Unix timestamp (in seconds) of the game.</p> <code>'t'</code> <code>additional_regressors</code> <code>Optional[List[Regressor]]</code> <p>Additional regressors to include, e.g. home advantage.</p> <code>None</code> <code>track_rating_history</code> <code>bool</code> <p>Flag to track historical ratings of entities.</p> <code>False</code> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>def __init__(\n    self,\n    k_factor: float,\n    default_init_rating: float,\n    beta: float = 200,\n    init_ratings: Optional[Dict[str, Tuple[Optional[int], float]]] = None,\n    entity_cols: Tuple[str, str] = (\"entity_1\", \"entity_2\"),\n    score_col: str = \"score\",\n    date_col: str = \"t\",\n    additional_regressors: Optional[List[Regressor]] = None,\n    track_rating_history: bool = False,\n) -&gt; None:\n    \"\"\"\n    Parameters\n    ----------\n    k_factor : float\n        Elo K-factor/step-size for gradient descent for the entities.\n    default_init_rating : float\n        Default initial rating for entities.\n    beta : float\n        Normalization factor for ratings when computing expected score.\n    init_ratings : Optional[Dict[str, Tuple[Optional[int], float]]]\n        Initial ratings for entities (dictionary of form entity: (Unix timestamp, rating))\n    entity_cols : Tuple[str, str]\n        Names of columns identifying the names of the entities playing the games.\n    score_col : str\n        Name of score column (1 if entity_1 wins and 0 if entity_2 wins).\n        Draws are not currently supported.\n    date_col : str\n        Name of date column, which has Unix timestamp (in seconds) of the\n        game.\n    additional_regressors : Optional[List[Regressor]]\n        Additional regressors to include, e.g. home advantage.\n    track_rating_history : bool\n        Flag to track historical ratings of entities.\n    \"\"\"\n    super().__init__(\n        model_type=PoissonRegression,\n        k_factor=k_factor,\n        default_init_rating=default_init_rating,\n        beta=beta,\n        init_ratings=init_ratings,\n        entity_cols=entity_cols,\n        score_col=score_col,\n        date_col=date_col,\n        additional_regressors=additional_regressors,\n        track_rating_history=track_rating_history,\n    )\n</code></pre>"},{"location":"api/#elo_grad.RegressionRatingSystemMixin","title":"<code>RegressionRatingSystemMixin</code>","text":"<p>               Bases: <code>RatingSystemMixin</code></p> <p>Mixin class for regression rating systems.</p> <p>This mixin defines the following functionality:</p> <ul> <li><code>_estimator_type</code> class attribute defaulting to <code>\"regressor\"</code>;</li> <li><code>score</code> method that default to :func:<code>~sklearn.metrics.mean_poisson_deviance</code>.</li> <li>enforce that <code>fit</code> does not require <code>y</code> to be passed through the <code>requires_y</code> tag.</li> </ul> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>class RegressionRatingSystemMixin(RatingSystemMixin):\n    \"\"\"\n    Mixin class for regression rating systems.\n\n    This mixin defines the following functionality:\n\n    - `_estimator_type` class attribute defaulting to `\"regressor\"`;\n    - `score` method that default to :func:`~sklearn.metrics.mean_poisson_deviance`.\n    - enforce that `fit` does not require `y` to be passed through the `requires_y` tag.\n    \"\"\"\n\n    def predict(self, X):\n        return self._transform(X, return_expected_score=True)  # type:ignore\n</code></pre>"},{"location":"api/#elo_grad.Regressor","title":"<code>Regressor</code>  <code>dataclass</code>","text":"<p>Regressor for Elo rating system (additional to entities).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of regressor column in dataset.</p> required <code>k_factor</code> <code>Optional[float]</code> <p>k-factor for this regressor's dimension. If None, the global k-factor for entities is used.</p> <code>None</code> <code>lambda_reg</code> <code>Optional[float]</code> <p>Regularisation parameter for regressor model coefficient, if L1 or L2 regularisation is used.</p> <code>None</code> <code>penalty</code> <code>Optional[str]</code> <p>Specify the norm of the penalty:</p> <ul> <li><code>None</code>: no penalty is added</li> <li><code>l1</code>: add a L1 penalty term</li> <li><code>l2</code>: add a L2 penalty term</li> </ul> <code>None</code> Source code in <code>src/elo_grad/__init__.py</code> <pre><code>@dataclass(frozen=True)\nclass Regressor:\n    \"\"\"\n    Regressor for Elo rating system (additional to entities).\n\n    Parameters\n    ----------\n    name : str\n        Name of regressor column in dataset.\n    k_factor : Optional[float]\n        k-factor for this regressor's dimension. If None, the global k-factor for entities is used.\n    lambda_reg : Optional[float]\n        Regularisation parameter for regressor model coefficient, if L1 or L2 regularisation is used.\n    penalty : Optional[str]\n        Specify the norm of the penalty:\n\n        - `None`: no penalty is added\n        - `l1`: add a L1 penalty term\n        - `l2`: add a L2 penalty term\n    \"\"\"\n    name: str\n    k_factor: Optional[float] = None\n    lambda_reg: Optional[float] = None\n    penalty: Optional[str] = None\n\n    def __post_init__(self):\n        if self.penalty is not None and self.penalty not in (\"l1\", \"l2\"):\n            raise ValueError(\"Penalty must be None, 'l1' or 'l2'.\")\n</code></pre>"},{"location":"intro/","title":"Elo as Logistic Regression","text":"<p>EloGrad is motivated by the framing of the Elo rating system as logistic regression with gradient descent, and the natural extensions to the rating system that arise from that. We derive that relationship here.</p> <p>In <code>elo-grad</code>, we implement the Elo rating system as logistic regression with mini-batch gradient descent,  where batches are defined by date rather than stochastic gradient descent.</p>"},{"location":"intro/#elo-rating-system","title":"Elo Rating System","text":"<p>In the Elo rating system, we have a set of entities, \\(i=1,\\cdots,n\\), with corresponding ratings \\(r_1,\\cdots,r_n\\). The expected score/outcome of a game between entities \\(i\\) and \\(j\\) is given by $$ \\begin{equation} \\mathbb{E}[y_{ij}|r_1,\\cdots,r_n] = \\frac{1}{1 + 10^{-(r_i - r_j) / 2\\beta}}, \\end{equation} $$ where \\(\\beta\\) is a normalisation factor and \\(y_{ij}\\) is the score/outcome of a game between entity \\(i\\) and \\(j\\): $$ \\begin{equation} y_{ij} =  \\begin{cases} 1 &amp; \\text{if}\\,i\\,\\text{wins}, \\\\ 0 &amp; \\text{if}\\,j\\,\\text{wins}. \\end{cases} \\end{equation} $$ NOTE: we are restricting ourselves to a binary outcome.</p> <p>After a game, each entity's rating is updated as $$ \\begin{equation} r^\\prime_i=r_i + k \\left(y_{ij} - \\mathbb{E}[y_{ij}|r_1,\\cdots,r_n]\\right), \\end{equation} $$ where \\(k\\) is the k-factor. </p>"},{"location":"intro/#logistic-regression","title":"Logistic Regression","text":"<p>Suppose we have a binary outcome \\(y|\\mathbf{x}\\sim\\text{Bernoulli}(p)\\), where \\(\\mathbf{x}\\) is the set of input variables/regressors and \\(p\\) is the outcome probability. If we model this outcome with model parameters \\(\\mathbf{w}\\), the likelihood function is given by $$ \\begin{equation} \\mathcal{L}(\\mathbf{w})= p(y|\\mathbf{w};\\mathbf{x})^y\\left(1-p(y|\\mathbf{w};\\mathbf{x})\\right)^{1-y}. \\end{equation} $$</p> <p>The logistic regression model assumes the outcome probability is given by $$ \\begin{equation} p(y|\\mathbf{w};\\mathbf{x})= \\frac{1}{1 + e^{-\\mathbf{w}\\cdot\\mathbf{x}}}. \\end{equation} $$ We have not included an intercept.</p> <p>Suppose each observation corresponds to a game between two of \\(n\\) entities and we have one regressor for each entity. For each game we (arbitrarily) define an order for the entities - let the first entity be denoted by \\(i\\) and the second by \\(j\\). For each game, the regressor corresponding to entity \\(i\\) takes value \\(1\\) and the regressor corresponding to entity \\(j\\) takes value \\(-1\\). Regressors corresponding to other entities take value \\(0\\). We can represent this as</p> \\[ \\begin{equation} \\mathbf{x}_k=\\delta_{ik} - \\delta_{jk}, \\end{equation} \\] <p>where \\(\\delta_{ij}\\) is the Kronecker delta.</p> <p>The table below shows how the data would look like for two games:</p> <ul> <li>team \\(1\\) beats team \\(2\\) on 01/01/24,</li> <li>team \\(n\\) beats team \\(1\\) on 02/01/24.</li> </ul> Date y Team 1 Team 2 Team 3 ... Team n 01/01/24 1 1 -1 0 ... 0 02/01/24 0 -1 0 0 ... 1 ... ... ... ... ... ... ... <p>We can equivalently represent the games as</p> Date y Team 1 Team 2 Team 3 ... Team n 01/01/24 0 -1 1 0 ... 0 02/01/24 1 1 0 0 ... -1 ... ... ... ... ... ... ... <p>i.e. flipping the outcome variable and changing the sign of the regressors.</p> <p>With the regressors described above, we can rewrite (5) as $$ \\begin{equation} p(y_{ij}|\\mathbf{w};\\mathbf{x})= \\frac{1}{1 + e^{-(w_i - w_j)}}, \\end{equation} $$ where, as in (2), \\(y_{ij}\\) represents the score/outcome of a game between team \\(i\\) and \\(j\\). If we define \\(r_i:=2\\beta w_i/\\ln 10\\) then we recover the Elo expected score/outcome equation (1).</p>"},{"location":"intro/#stochastic-gradient-descent","title":"Stochastic Gradient Descent","text":"<p>Stochastic gradient descent (SGD) is a commonly used optimisation method. It is an approximation of gradient descent  and can be used to perform maximum likelihood estimation (MLE) for logistic regression. SGD approximates the gradient descent process by updating parameters based on one sample at time (or a small set of samples at a time, which is sometimes called mini-batch gradient descent). This is typically used when it is computationally infeasible to fit the model using all samples at once.</p> <p>Gradient descent identifies the direction in parameter space in which a loss function decreases fastest. It updates the parameters by stepping in this direction. We can write this as $$ \\begin{equation} \\mathbf{w}^t=\\mathbf{w}^{t-1} - \\alpha\\nabla_{\\mathbf{w}} L, \\end{equation} $$ where \\(L\\) is the loss function to be optimized, \\(\\alpha\\) is the step size, \\(\\mathbf{w}^t\\) are the model parameters at step \\(t\\) and \\(\\nabla_{\\mathbf{w}}\\) is the gradient with respect to the model parameters.</p> <p>The update method for SGD is given by $$ \\begin{equation} \\mathbf{w}^t=\\mathbf{w}^{t-1} - \\alpha\\nabla_{\\mathbf{w}}^{a} L, \\end{equation} $$ where \\(\\nabla_{\\mathbf{w}}^{a}\\) is the gradient with respect to the model parameters,  evaluated for observation \\(a\\) which is usually randomly selected. For mini-batch gradient descent, \\(a\\) represents a set of samples.</p>"},{"location":"intro/#sgd-for-logistic-regression","title":"SGD for Logistic Regression","text":"<p>We can perform gradient descent for logistic regression by minimising the negative log-likelihood. The gradient of the negative log likelihood for logistic regression is given by $$ \\begin{align} \\nabla_{\\mathbf{w}}\\mathcal l &amp;= -\\sum_a \\left[ y_a \\frac{\\nabla_{\\mathbf{w}}p(y_a|\\mathbf{w};\\mathbf{x_a})}{p(y_a|\\mathbf{w};\\mathbf{x_a})} -\\frac{(1 - y_a)(\\nabla_{\\mathbf{w}}p(y|\\mathbf{w};\\mathbf{x}_a)}{1 - p(y_a|\\mathbf{w};\\mathbf{x}_a)} \\right],\\\\ &amp;=-\\sum_a\\left[ y_a(1 - p(y_a|\\mathbf{w};\\mathbf{x}_a)) - (1 - y_a)p(y_a|\\mathbf{w};\\mathbf{x}_a)) \\right]\\mathbf{x}_a,\\\\ &amp;=\\sum_a\\left[p(y_a|\\mathbf{w};\\mathbf{x}_a) - y_a\\right]\\mathbf{x}_a, \\end{align} $$ where \\(p(y_a|\\mathbf{w};\\mathbf{x}_a)\\) is the logistic function (5), \\(l\\) is the negative log-likelihood and \\(a\\) runs over the set of observations/games.</p> <p>The update method for the model parameters is then given by $$ \\begin{equation} \\mathbf{w}^t =\\mathbf{w}^{t-1} + \\alpha \\sum_a \\left(y_a - p(y|\\mathbf{w};\\mathbf{x}_a)\\right). \\end{equation} $$</p> <p>If we have the regressors described in the Logistic Regression section above and restrict ourselves to stochastic gradient descent,  this becomes $$ \\begin{equation} \\mathbf{w}^t =\\mathbf{w}^{t-1} + \\alpha \\left(y_{ij} - \\frac{1}{1 + e^{-(w_i - w_j)}}\\right). \\end{equation} $$ Using \\(r_i=2\\beta w_i/\\ln 10\\), this becomes $$ \\begin{equation} \\mathbf{r}^t =\\mathbf{r}^{t-1} + \\frac{2\\alpha\\beta}{\\ln10} \\left(y_{ij} - \\frac{1}{1 + 10^{-(r_i - r_j) / 2\\beta}}\\right). \\end{equation} $$ Defining \\(k:=2\\alpha\\beta / \\ln10\\), we recover (3) and the Elo rating system.</p>"},{"location":"intro/#references","title":"References","text":"<p>This package was inspired by reading this blog.</p>"},{"location":"feature_ref/additional_regressors/","title":"Additional Regressors","text":"<p>Having framed the Elo rating system as logistic regression with stochastic gradient descent (see Elo as Logistic Regression) it is straightforward to add additional regressors. We modify (1) from Elo as Logistic Regression as $$ \\begin{equation} \\mathbb{E}[y_{ij}|r_1,\\cdots,r_n;\\hat{r}_k] = \\frac{1}{1 + 10^{-(r_i - r_j + \\hat{r}_k x_k) / 2\\beta}}, \\end{equation} $$ where \\(\\hat{r}_k\\) denote the \"ratings\" of the additional regressors and \\(x_k\\) is the value of the additional regressors for the game. The update method for the entities remains unchanged, i.e. given by (3) from Elo as Logistic Regression, except we now also condition the expectation on the additional regressors. The update method for the additional regressors is given by</p> \\[ \\begin{equation} \\hat{r}^\\prime_k=\\hat{r}_k + k \\left(y_{ij} - \\mathbb{E}[y_{ij}|r_1,\\cdots,r_n;\\hat{r}_k]\\right)x_k. \\end{equation} \\] <p>It is often useful to specify a different k-factor/step-size for the additional regressors than for the entities, as the variance can be quite different for the additional regressors. Equivalently, we could scale our regressors appropriately before passing the data to the rating system. For convenience <code>elo-grad</code> allows the specification of different k-factors for the additional regressors (see Example).</p>"},{"location":"feature_ref/additional_regressors/#example","title":"Example","text":"<pre><code>from elo_grad import EloEstimator, Regressor\n\n# Input DataFrame with sorted index of Unix timestamps\n# and columns entity_1 | entity_2 | score | home\n# where score = 1 if player_1 won and score = 0 if\n# player_2 won. In all games, entity_1 has home\n# advantage, so home = 1 for all rows.\nhome_col = \"home\"\ndf = ...\nestimator = EloEstimator(\n    k_factor=20, \n    default_init_rating=1200,\n    entity_cols=(\"player_1\", \"player_2\"),\n    score_col=\"result\",\n    # Set the initial rating for home advantage to 0\n    init_ratings={home_col: (None, 0)},  \n    # Set k-factor/step-size to 1 for the home advantage regressor\n    additional_regressors=[Regressor(name=home_col, k_factor=1)],\n)\n# Get expected scores\nexpected_scores = estimator.predict_proba(df)\n# Get final ratings (of form (Unix timestamp, rating)) for home advantage\nratings = estimator.model.ratings[home_col]\n</code></pre>"},{"location":"feature_ref/additional_regressors/#other-approaches","title":"Other Approaches","text":"<p>The Elo rating system is the basis for 538's NFL predictions. There are a number of differences in their approach - notably they incorporate margin of victory.</p> <p>Focusing on regressors, they include additional regressors such as home advantage and rest adjustment, although these are fixed rather than fitted values. Interestingly, they also include a play-off adjustment factor which multiplies the rating difference. To include such a factor, we would need to allow interaction terms between a play-off flag and the entities  (see Roadmap).</p>"},{"location":"feature_ref/poisson/","title":"Poisson Elo","text":"<p>If we can frame the Elo rating system as logistic regression, why not define other rating systems based on other  generalized linear models (GLMs)? We do just that and derive a rating system equivalent to  Poisson regression here.</p>"},{"location":"feature_ref/poisson/#motivation","title":"Motivation","text":"<p>Poisson regression models count data as the response variable. This can be useful for sports such as football, where we can predict the number of goals a team will score.</p> <p>The Poisson model is even used to model binary outcomes in cases where we are interested in relative risk ratios rather than the odds ratio. The latter is easily extracted from the logistic regression model but is non-intuitive, while the former is hard to extract from the logistic regression model but straightforward to extract from the Poisson model.</p>"},{"location":"feature_ref/poisson/#poisson-regression","title":"Poisson Regression","text":"<p>Suppose we have a count response \\(y|\\mathbf{x}\\sim\\text{Poisson}(\\lambda)\\), where \\(\\mathbf{x}\\) is the set of input variables/regressors  and \\(\\lambda\\) is the expectation of response in a given interval. If we model this outcome with model parameters \\(\\mathbf{w}\\), the likelihood function is given by $$ \\begin{equation} \\mathcal{L}(\\mathbf{w})= \\frac{\\lambda(\\mathbf{w;x})^y e^{-\\lambda(\\mathbf{w;x})}}{y!}. \\end{equation} $$ As in Elo as Logistic Regression, we are ignoring the product over samples for the moment.</p> <p>The Poisson model assumes the count response is given by $$ \\begin{equation} \\lambda(\\mathbf{w};\\mathbf{x})= e^{\\mathbf{w}\\cdot x}. \\end{equation} $$ We have not included an intercept although this can easily be added using an additional regressor (see the example).</p> <p>Suppose each observation corresponds to the number of points/goals scored in a given interval between two of \\(n\\) entities. We can define two ratings for each entity - one for their attacking ability and one for their defensive ability. Let the index \\(i\\) run over the attacking abilities and the index \\(\\underbar{i}\\) run over the defensive abilities.</p> <p>We can write our regressors as</p> \\[ \\begin{equation} \\mathbf{x}_k=\\delta_{ik} - \\delta_{j\\underbar{k}}, \\end{equation} \\] <p>where \\(\\delta_{ij}\\) is the Kronecker delta. The table below shows how the data would look like for three observations:</p> <ul> <li>team \\(1\\) scores two goals against team \\(2\\) on 01/01/24,</li> <li>team \\(2\\) scores one goal against team \\(1\\) on 01/01/24,</li> <li>team \\(n\\) score no goals against team \\(1\\) on 02/01/24.</li> </ul> Date y Team 1 (A) Team 2 (A) Team 3 (A) ... Team n (A) Team 1 (D) Team 2 (D) Team 3 (D) ... Team n (D) 01/01/24 2 1 0 0 ... 0 0 -1 0 ... 0 01/01/24 1 0 1 0 ... 1 -1 0 0 ... 0 02/01/24 0 0 0 0 ... 1 -1 0 0 ... 0 ... ... ... ... ... ... ... ... ... ... ... ... <p>where (A) indicates attacking ability and (D) defensive ability.</p> <p>With the regressors described above, we can rewrite (2) as $$ \\begin{equation} \\lambda(\\mathbf{w};\\mathbf{x})= \\exp(w_i - w_{\\underbar{j}}), \\end{equation} $$ where \\(y_{ij}\\) represents the goals scored by team \\(i\\) against \\(j\\). Recalling that \\(\\lambda\\) is the expected count, we can then write $$ \\begin{equation} \\mathbb{E}\\left[y_{ij}|w_1,\\cdots w_n\\right]= \\exp(w_i - w_{\\underbar{j}}). \\end{equation} $$</p>"},{"location":"feature_ref/poisson/#stochastic-gradient-descent","title":"Stochastic Gradient Descent","text":"<p>It remains to find the update method for the rating system, which is just (mini-batch) stochastic gradient descent (SGD).</p> <p>We can perform gradient descent for Poisson regression by minimising the negative log-likelihood. The gradient of the negative log likelihood for Poisson regression is given by $$ \\begin{align} \\nabla_{\\mathbf{w}}\\mathcal l &amp;= -\\sum_a \\left[ y_a \\frac{\\nabla_{\\mathbf{w}}\\lambda(\\mathbf{w};\\mathbf{x}_a)}{\\lambda(\\mathbf{w};\\mathbf{x}_a)} - \\lambda(\\mathbf{w};\\mathbf{x}_a) \\nabla_a \\lambda(\\mathbf{w};\\mathbf{x}_a) \\right],\\\\ &amp;=-\\sum_a\\left[ y_a \\mathbf{x}_a - (1 - y_a)p(y|\\mathbf{w};\\mathbf{x}_a)) \\right]\\mathbf{x}_a,\\\\ &amp;=\\sum_a\\left[\\lambda(\\mathbf{w};\\mathbf{x}) - y_a\\right]\\mathbf{x}_a, \\end{align} $$ where \\(\\lambda(\\mathbf{w};\\mathbf{x})\\) is the expected count (2), \\(l\\) is the negative log-likelihood and \\(a\\) runs over the set of observations/games.</p> <p>The update method for the model parameters is then given by $$ \\begin{equation} \\mathbf{w}^t =\\mathbf{w}^{t-1} + \\alpha \\sum_a \\left(y_a - \\lambda(\\mathbf{w};\\mathbf{x})\\right). \\end{equation} $$</p> <p>If we have the regressors described in the  Poisson Regression section  above and restrict ourselves to stochastic gradient descent,  this becomes $$ \\begin{equation} \\mathbf{w}^t =\\mathbf{w}^{t-1} + \\alpha \\left(y_{ij} - \\exp(w_i - w_{\\underbar{j}})\\right) \\end{equation} $$ or $$ \\begin{equation} \\mathbf{r}^t =\\mathbf{r}^{t-1} + k \\left(y_{ij} - 10^{(r_i - r_{\\underbar{j}}) / 2\\beta}\\right). \\end{equation} $$ where \\(r_i:=2\\beta w_i / \\ln 10\\) and \\(k:=2\\alpha\\beta / \\ln10\\). We perform this change of variables to align with Elo conventions. Now (5) is given by $$ \\begin{equation} \\mathbb{E}\\left[y_{ij}|r_1,\\cdots r_n\\right]= 10^{(r_i - r_{\\underbar{j}}) / 2\\beta}. \\end{equation} $$</p>"},{"location":"feature_ref/poisson/#with-additional-regressors","title":"With Additional Regressors","text":"<p>Following Additional Regressors, equation (11) become</p> \\[ \\begin{equation} \\mathbb{E}\\left[y_{ij}|r_1,\\cdots r_n;\\hat{r}_k\\right]= 10^{(r_i - r_{\\underbar{j}} + \\hat{r}_k x_k) / 2\\beta}. \\end{equation} \\] <p>with (10) modified accordingly. </p>"},{"location":"feature_ref/poisson/#example","title":"Example","text":"<p>We provide a more detailed example, including details of how data can be pre-processed to pass to the rating system in <code>examples/football.ipynb</code>.</p> <pre><code>from elo_grad import PoissonEloEstimator, Regressor\n\n# Input DataFrame with sorted index of Unix timestamps\n# and columns entity_1_attacking | entity_2_defensive | score | home | intercept\n# where score is the number of points/goals scored\n# by entity 1 against entity 2 and home is a Boolean flag indicating home advantage.\n# intercept is a column with all 1s which represents the mean number of goals\n# when entities are evenly matched and there is no home advantage.\nintercept_col = \"intercept\"\nhome_col = \"home\"\ndf = ...\nestimator = PoissonEloEstimator(\n    k_factor=20, \n    default_init_rating=1200,\n    entity_cols=(\"entity_1_attacking\", \"entity_2_defensive\"),\n    score_col=\"result\",\n    # Set the initial rating for home advantage to 0\n    init_ratings={intercept_col: (None, 0), home_col: (None, 0)},  \n    # Set k-factor/step-size to 1 for the both the mean and home advantage regressor\n    additional_regressors=[Regressor(name=intercept_col, k_factor=1), Regressor(name=home_col, k_factor=1)],\n)\n# Get expected scores\nexpected_scores = estimator.predict(df)\n# Get final ratings (of form (Unix timestamp, rating)) for home advantage\nratings = estimator.model.ratings[home_col]\n</code></pre>"},{"location":"feature_ref/poisson/#other-approaches","title":"Other Approaches","text":"<p>The Elo rating system is the basis for  538's NFL predictions. They use the traditional, logistic regression-based Elo rating system but also incorporate margin of victory. They do this by including a multiplier in the update method. Given the natural equivalence of the Elo rating system with logistic regression, we believe this is not a very natural way to include margin of victory and that using a Poisson-based Elo should be preferred.</p>"},{"location":"feature_ref/poisson/#references","title":"References","text":"<p>A Poisson regression-based Elo rating system was implemented  here and provided the inspiration for this. Note that the update methods used there are not the same.</p>"},{"location":"feature_ref/regularisation/","title":"Regularisation","text":"<p>Regularisation is a commonly used way to reduce model  variance. EloGrad supports  L1  and  L2  regularisation methods.</p> <p>NOTE: EloGrad does not support regularisation for the entity weights - only additional regressors.</p>"},{"location":"feature_ref/regularisation/#l1","title":"L1","text":"<p>L1 regularisation modifies the cost function to be optimised by</p> \\[ \\begin{equation} L_{\\text{L1}} = L + \\lambda \\sum_i \\left|w_i\\right|,   \\end{equation} \\] <p>where \\(\\lambda\\) is the regularisation parameter and \\(w_i\\) are the model weights.</p> <p>For both the logistic regression-based and Poisson regression-based Elo rating systems,  it is straightforward to show that the update method becomes</p> \\[ \\begin{equation} \\hat{r}^\\prime_k=\\hat{r}_k + k \\left(y_{ij} - \\mathbb{E}[y_{ij}|r_1,\\cdots,r_n;\\hat{r}_k]\\right)x_k - k\\lambda\\,\\text{sign}(\\hat{r}_k), \\end{equation} \\] <p>where \\(\\text{sign}(x)\\) is the sign function. </p>"},{"location":"feature_ref/regularisation/#l2","title":"L2","text":"<p>L1 regularisation modifies the cost function to be optimised by</p> \\[ \\begin{equation} L_{\\text{L1}} = L + \\lambda \\sum_i w_i^2. \\end{equation} \\] <p>For both the logistic regression-based and Poisson regression-based Elo rating systems,  it is straightforward to show that the update method becomes</p> \\[ \\begin{equation} \\hat{r}^\\prime_k=\\hat{r}_k + k \\left(y_{ij} - \\mathbb{E}[y_{ij}|r_1,\\cdots,r_n;\\hat{r}_k]\\right)x_k - 2k\\lambda\\hat{r}_k. \\end{equation} \\]"},{"location":"feature_ref/regularisation/#example","title":"Example","text":"<pre><code>from elo_grad import EloEstimator, Regressor\n\n# Input DataFrame with sorted index of Unix timestamps\n# and columns entity_1 | entity_2 | score | home\n# where score = 1 if player_1 won and score = 0 if\n# player_2 won. In all games, entity_1 has home\n# advantage, so home = 1 for all rows.\nhome_col = \"home\"\ndf = ...\nestimator = EloEstimator(\n    k_factor=20, \n    default_init_rating=1200,\n    entity_cols=(\"player_1\", \"player_2\"),\n    score_col=\"result\",\n    # Set the initial rating for home advantage to 0\n    init_ratings={home_col: (None, 0)},  \n    # Set k-factor/step-size to 1 for the home advantage regressor\n    # and set an L1 penalty with lambda = 0.1\n    additional_regressors=[Regressor(name=home_col, k_factor=1, penalty=\"l1\", lambda_reg=0.1)],\n)\n# Get expected scores\nexpected_scores = estimator.predict_proba(df)\n# Get final ratings (of form (Unix timestamp, rating)) for home advantage\nratings = estimator.model.ratings[home_col]\n</code></pre>"}]}